# 编程能力考察

**报名号**：2021\*\*\*\*\*\*\*

**考生姓名**：张喆

[toc]

------

> 按顺序针对每道题解释解题思路，并列举已经使用并通过的测试用例

## 第一题

根据题目中的输入, 采用数组存储该二叉树(但是存在问题,下述)

`getLeftChild()`, `getRightChild()`: 由于题设为二叉树, 设根节点`index=0`, 因此可以通过$2*i+1$和 $2*i+1$分别获取某节点的左右儿子.

`getSubTree()`: 由于删除一边划分成两棵子树, 因此需要获取任何节点子树的情况,可以通过自上而下的方法将所有子孙节点信息拿到(类似「堆」). 这里采用树的层序遍历,通过队列, 如果左右儿子存在则将他们加入队列, 不停出队进入下一层, 直到队列为空且即达到树的最深层, 期间将所有节点信息存入数组

由于必须划分为两棵树, 所以从`index=1`开始循环到最后一个位置, 如果该节点有子树,则调用上述`getSubTree()`获取子树的所有节点,并计算所需的乘积, 取最大的一个作为输出.

> [问题]
>
> 由于第二个测试用例给出的树的输入并不是按照完全二叉树从左至右从上至下的顺序,因此在构建树的时候出现一些问题,如果按照该算法,应该输入的为
>
> 1,null,2,null,null,3,4,null,null,null,null,null,null,5,6
>
> 由于核心算法并不是如何根据输入构建树, 因此这里暂时跳过, 如果还有时间则继续完善, 望老师谅解

- [x] 测试用例1
- [ ] 测试用例2 (输入问题, 无法创建标准的树模型)
  - [x] 等价结果

------

## 第二题

该题的抽象背景是要确定两两的关系 ,因此首选用图进行描述. 由于做题时间有限, 采用邻接矩阵进行存储, 由于测试用例体量较小便于调试.

首先根据输入第一行的信息 (总人数,记录数)初始化一个总人数$^2$规模的邻接矩阵, 且置每项为0, 接下来对于每行的输入,  如果:

- 左边>右边, 置该位为1
- 左边=右边, 置该位为2
- 左边<右边, 置该位为-1

对于是否冲突可以采用拓扑排序完成, 如果拓扑排序发现图中存在环, 则信息包含冲突

对于信息是否完全可以采用闭包完成, 根据已有信息进行不断的闭包运算至邻接矩阵不再扩充, 如果图中包含所有信息则信息完全, 否则一定存在某两个人`i`和`j`, 在邻接矩阵中而且的位为0, 无法判断他们的大小关系

> 由于时间有限, 在构建完基础的邻接矩阵之后, 逐行扫描, 获取所有比该行元素大的人和比它小的人. 对于每个比它大的人都应该比比它小的人还大, 如果有不满足该性质的两对人则可以判断信息中包含冲突, 如果二者之前没有信息则进行信息扩充. 全部扫描之后如果没有冲突则判断是否有无法确定的一对人, 如果有的话则信息不完全. 
>
> *注. 由于时间有限, 该实现算法复杂度较高, 如果有时间将会按照上述黑色算法重构代码, 望老师见谅*

- [x] 测试用例1
- [x] 测试用例2
- [x] 测试用例3

------

## 第三题

当前字符串的解码数量可以由比他少一位的字串的解码数量确定, 因此可以用动态规划算法解决

**循环**:

- 当前位置是`0`: 只有当前一位是1或2才可以通过两位数进行解码; 否则则该串无法解码
- 当前位置是`1~6`: 自身可以解码; 如果前一位是1或2又可以通过两位数进行解码
- 当前位置是`7~9`: 只有自身可以解码

**初始条件**: 空字符串不能解码; 首位为0的不能解码,否则第一位有一种解码方法

**具体数学形式**: 设某一位字符为code[i], 前一位字符为code[i-1],对code[i]其取值进行分类

- 0: 
  - code[i-1]为1或2: dp[i] = dp[i-2] + 1
  - 其他: 出错,无法解码
- 1~6: 
  - code[i-1]为1或2: dp[i] = dp[i-2]+2(如果想加2的前提是前一位不能自行解码,要推迟到与这位一同解码)
  - 其他: dp[i] = dp[i-1]+1
- 7~9: dp[i] = dp[i-1]+1

- [x] 测试用例1
- [x] 测试用例2
- [x] 测试用例3